<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://unpkg.com/three@0.140.2/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/7/Stats.min.js" integrity="sha512-ey3wf3z1WUgQ6/XU/lV1UVQkbCpWsyQANkBst88XXWHok9fXKp55G365lLhScYihGpkzhiZz75r+8isUSCKRIg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      // ページの読み込みを待つ
      window.addEventListener('DOMContentLoaded', init);

      var cityArray = []; // for cache
      var t0 = 0; // time when opened the
      var dt = 0; // used in calcDate
      var unixtime = 0;
      var now = 0;
      var loy, lom;
      var yourcity = {city: 'Kobe', iso2:'JP', lng:135.2745, lat:34.7344};
      var noon;

      function init() {
        t0 = new Date().getTime() / 1000;

        const cities = d3.csv('worldcities.csv', function(d){
          return {
            id: parseInt(d.id),
            city: d.city,
            iso2: d.iso2,
            lng: parseFloat(d.lng),
            lat: parseFloat(d.lat)
          }
        })

        const stats = new Stats();
        document.body.appendChild(stats.domElement);
        // サイズを指定
        // const width = 1080;
        // const height = 720;
        const width = 800;
        const height = 800;
        var radius = parseInt(document.getElementById('radius').value);

        // レンダラーを作成
        const renderer = new THREE.WebGLRenderer({
          canvas: document.querySelector('#myCanvas'),
        });
        renderer.setSize(width, height);

        // シーンを作成
        const scene = new THREE.Scene();

        // カメラを作成
        const camera = new THREE.PerspectiveCamera(30, width / height, 500, 3000);
        // camera.position.set(0, 0, +1000);
        var perspectiveParams = parseInt(document.getElementById('perspective').value);
        camera.position.set(0, perspectiveParams * 1000, 0);
        camera.lookAt(new THREE.Vector3(0,0,0));

        // 太陽方向;
        const points = [];
        points.push(new THREE.Vector3(0, 0, 0));
        points.push(new THREE.Vector3(width*5, 0, 0)); // sun
        const solar = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(points),
          new THREE.LineBasicMaterial({color: 0x0000ff})
        );
        const points1 = [];
        points1.push(new THREE.Vector3(-150, 0, 0));
        points1.push(new THREE.Vector3(width*5, 0, 0)); //moon
        const lunar = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(points1),
          new THREE.LineBasicMaterial({color: 0x00ff00})
        );

        // 球体を作成
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        // const wireframe = new THREE.WireframeGeometry(geometry, 0x00ff00);
        // const line = new THREE.LineSegments(wireframe);

        // 画像を読み込む
        const loader = new THREE.TextureLoader();
        const texture = loader.load('img/earthmap1k.jpg');
        // マテリアルにテクスチャーを設定
        const material = new THREE.MeshStandardMaterial({
          map: texture,
          // transparent: true,
          // opacity: 0.5,
          transparent: false
        });
        // メッシュを作成
        const earth = new THREE.Mesh(geometry, material);
        // 3D空間にメッシュを追加
        scene.add(earth);
        scene.add(solar);
        scene.add(lunar);

        // 平行光源
        const directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(1, 0, 0);
        //directionalLight.position.set(0, 1, 0);
        // シーンに追加
        scene.add(directionalLight);


        tick();

        // 毎フレーム時に実行されるループイベントです
        function tick() {
          const theta0 = hms2rad('15:32:00') - Math.PI;
          const thetaMoon0 = hms2rad('13:55:00'); // Moon right ascension
          // console.log(theta0e;
          const equinox = new Date('2022-03-22 00:32:00').getTime()/ 1000; // 15:32:00UTC
          unixtime = new Date().getTime() / 1000;
          if (document.getElementById('epoch').value == 'equinox'){
            now = unixtime - t0 + dt;
          } else if (document.getElementById('epoch').value == 'now'){
            now = unixtime - equinox + dt;
          }
          document.getElementById('current').textContent = now.toFixed(2);

          // length of sidereal year, sidereal month
          loy = parseFloat( document.getElementById('loy').textContent);
          lom = parseFloat(document.getElementById('lom').textContent);

          // radian per frame
          var playspeed = parseFloat( document.getElementById('playspeed').value);
          dt += (playspeed - 1)/60;
          var frame = (now * 60 * playspeed).toFixed(0);
          // var frame = parseInt( document.getElementById('frame').textContent);
          // frame += parseInt(document.getElementById('control').value);

          const radianPerSecond = 2 * Math.PI / 86400 * (loy + 1) / loy; // earth
          const radianPerSecond1 = radianPerSecond / loy; // solar
          const radianPerSecond2 = (radianPerSecond1 * lom * 86400 + 2 * Math.PI) / lom / 86400 // moon

          const deltaMoonSeconds = thetaMoon0 / (radianPerSecond2-radianPerSecond1)

          // camera
          var fov = parseInt(document.getElementById('fov').value);
          var near = parseInt(document.getElementById('near').value);
          var far = parseInt(document.getElementById('far').value);
          camera.fov = fov;
          camera.near = near;
          camera.far = far;
          camera.updateProjectionMatrix();
          distance = parseInt(document.getElementById('camera').value);
          var perspectiveParams = document.getElementById('perspective').value.split(',').map(Number);
          camera.position.set(perspectiveParams[0]*distance, perspectiveParams[1]*distance, perspectiveParams[2]*distance);
          camera.lookAt(new THREE.Vector3(0,0,0));

          // scale the size of the earth
          radius = parseInt(document.getElementById('radius').value);
          var scale = radius / 300;
          earth.scale.setScalar(scale);

          // based on second
          earth.rotation.y = now * radianPerSecond + theta0;

          // solar motion
          solar.rotation.y = now * radianPerSecond1;
          var sin = Math.sin(solar.rotation.y);
          var cos = Math.cos(solar.rotation.y);
          directionalLight.position.set(cos, sin*Math.sin(Math.PI * 2 * 23.4 / 360), -sin);
          earth.position.y = -sin * radius; // approaching to celestial north pole

          // lunar motion
          earth.position.x = -Math.cos(radianPerSecond2 * now + thetaMoon0) * radius * .75;
          earth.position.z = Math.sin(radianPerSecond2 * now + thetaMoon0) * radius * .75;
          lunar.rotation.y = radianPerSecond2 * now + thetaMoon0;

          // longitude at noon
          noon = ((-earth.rotation.y + solar.rotation.y) / Math.PI / 2 * 360) % 360;
          if (noon < -180){
            noon = noon + 360;
          } else if (noon > 180) {
            noon = noon - 360;
          }

          var localtime = (noon - yourcity.lng);
          if (localtime < -180) {
            localtime = localtime + 360;
          } else if (localtime > 180) {
            localtime = localtime - 360;
          }
          document.getElementById('noon').textContent = (localtime).toFixed(4);

          // plot cities
          if ((unixtime % 1).toFixed(1) == 0){
            plotCities(scene, radius, cities, playspeed, now, theta0, earth, solar);
          };

          document.getElementById('frame').textContent = frame;
          document.getElementById('solarday').textContent = dms(now, playspeed, 'year');
          document.getElementById('lunarday').textContent = dms(now+deltaMoonSeconds, playspeed, 'month');
          document.getElementById('fpsd').textContent = '60/' + playspeed;
          document.getElementById('sin').textContent = sin;
          document.getElementById('cos').textContent = cos;
          // レンダリング
          renderer.render(scene, camera);

          requestAnimationFrame(tick);
          stats.update();
        }
      }

      function plotCities(scene, radius, cities, playspeed, now, theta0, earth, solar){
        let lineheight = parseFloat(document.getElementById('lineheight').value);
        var notFound = true;
        var result = {};

        cities.then(function(data){ // async

          // remove first
          for (let key in cityArray){
            scene.remove(scene.getObjectByName(cityArray[key]));
          }
          let ul = document.getElementById('cities');
          ul.innerHTML = '';
          cityArray = [];

          // nearest to the noon
          result = data.filter(function(row){
            if (playspeed < 600){
              return row.lng >= noon && row.lng < noon + 15/3600 * playspeed;
            } else {
              return row.lng >= noon && row.lng < noon + 15/3600 * 600;
            }
          });

          // select the first comming next if not found
          if (result.length > 0){
            notFound=false;
          } else {
            result = data.filter(function (row){
              // return row.lng >= noon; // ago
              return row.lng < (noon + 15/3600 * playspeed); // in coming
            });
            // sort by longitude
            result.sort(function(a, b) {
              // return a.lng < b.lng ? -1 : 1; // ago
              return a.lng > b.lng ? -1 : 1; // in coming
              return 0;
            });
            result = [result[0]]; // only the first one
          }

          // sort by latitude
          result.sort(function(a, b) {
            return a.lat > b.lat ? -1 : 1;
            return 0;
          });

          // add your city first
          result.splice(0, 0, yourcity);

          console.log(noon, result.length);
          for (let key in result){
            var nadir = [];
            console.log(result[key]);
            var x = radius * (Math.cos(Math.PI * 2 * result[key].lat/360)); // to the sun
            var y = radius * Math.sin(Math.PI * 2 * result[key].lat/360); // to the pole
            nadir.push(new THREE.Vector3(x, y, 0));
            if (result[key].city == yourcity.city){
              var h = 1.5;
              var color = 0xff00ff;
            } else {
              var h = lineheight;
              var color = 0xff0000;
            }
            nadir.push(new THREE.Vector3(x*h, y*h, 0));
            const city = new THREE.Line(
              new THREE.BufferGeometry().setFromPoints(nadir),
              new THREE.LineBasicMaterial({color: color})
            );
            city.name = result[key].city;
            city.rotation.y = (Math.PI * 2 * result[key].lng/360) + earth.rotation.y;
            city.position.x = earth.position.x;
            city.position.y = earth.position.y;
            city.position.z = earth.position.z;
            city.geometry.attributes.position.needsUpdate = true;
            scene.add(city);

            cityArray.push(city.name);

          }
          listCities(noon, ul, result, notFound);
        })
      };

      function listCities(noon, ul, result, notFound){

        for (let key in result) {
          let li = document.createElement('li');
          let a = document.createElement('a');
          a.setAttribute('href', 'https://en.wikipedia.org/wiki/' + result[key].city);
          a.setAttribute('target', '_blank');
          a.appendChild(document.createTextNode(result[key].city));
          let emoji = getFlagEmoji(result[key].iso2);
          li.appendChild(document.createTextNode(emoji + ' '));
          li.appendChild(a);
          let dlon = result[key].lng - yourcity.lng;
          if (dlon > 180) {
            dlon = dlon-360;
          } else if (dlon < -180) {
            dlon = dlon+360;
          }

          if (notFound & dlon != 0) {
            // eta = ' (' + ((result[key].lng-noon)/15*3600).toFixed() + ' secs ago)'
            eta = ' (in ' + ((-result[key].lng+noon)/15*3600).toFixed() + ' secs)'
          } else { eta = ''}

          li.appendChild(document.createTextNode(' ('+ dlon.toFixed(4) +')' + eta));
          ul.appendChild(li);
        }
      }

      function divideBy(s, unit){
        // unit should be year or month
        var d, subunit;
        if (unit == 'year') {
          d = loy;
          subunit = 'season';
        } else if (unit == 'month'){
          d = lom;
          subunit = 'week';
        }
        let remainderSeconds = s % (86400 * (d / 4));
        let division1 = (s - remainderSeconds) / (86400 * d / 4); // total season or week
        let remainder1 = division1 % 4;
        let division = (division1 - remainder1) / 4
        return {division, remainder1, subunit, remainderSeconds}
      }

      function hms2rad(s){
        let arr = s.split(':').map(Number);
        let hour = arr[0];
        let minute = arr[1];
        let second = arr[2];
        return 2 * Math.PI * (hour * 3600 + minute * 60 + second) / 86400;
      }

      function dms(now, playspeed, unit){
        var {division, remainder1, subunit, remainderSeconds} = divideBy(now, unit);

        remainder = remainderSeconds % 86400;
        let day = (remainderSeconds-remainder) / 86400;
        remainder = remainder % 3600;
        let hour = (remainderSeconds - day*86400 - remainder) / 3600;
        let second = remainder % 60;
        let minute = (remainderSeconds - day*86400 - hour*3600 - second) / 60;
        return division.toFixed(0) + ' ' + unit + ' ' + remainder1.toFixed(0) + ' ' + subunit + ' ' + day.toFixed(0)+' day '+hour.toFixed(0)+':'+minute.toFixed(0)+':'+second.toFixed(2) + ' (' + now.toFixed(2) + ' seconds)'
      }

      function calcDate(e){
        switch (e.id) {
          case 'resetT0':
            dt = 0;
            return dt;
          case 'seasonplus':
            dt += 86400 * loy / 4;
            return dt;
          case 'seasonminus':
            dt -= 86400 * loy / 4;
            return dt;
            case 'weekplus':
            dt += 86400 * lom / 4;
            return dt;
          case 'weekminus':
            dt -= 86400 * lom / 4;
            return dt;
          case 'dayplus':
            dt += 86400;
            return dt;
          case 'dayminus':
            dt -= 86400;
            return dt;
          case 'hourplus':
            dt += 3600;
            return dt;
          case 'hourminus':
            dt -= 3600;
            return dt;
          case 'minplus':
            dt += 60;
            return dt;
          case 'minminus':
            dt -= 60;
            return dt;
          case 'secplus':
            dt += 1;
            return dt;
          case 'secminus':
            dt -= 1;
            return dt;
        }
      }

      function getFlagEmoji(countryCode) {
        const codePoints = countryCode
          .toUpperCase()
          .split('')
          .map(char =>  127397 + char.charCodeAt());
        return String.fromCodePoint(...codePoints);
      }

      function updatecity(){
        const cities = d3.csv('worldcities.csv', function(d){
          return {
            id: parseInt(d.id),
            city: d.city,
            iso2: d.iso2,
            lng: parseFloat(d.lng),
            lat: parseFloat(d.lat)
          }
        });

        let arr = document.getElementById('yourcity').value.split(',');
        cities.then(function(data){ // async
          result = data.filter(function(row){
            // https://stackoverflow.com/questions/5700636/using-javascript-to-perform-text-matches-with-without-accented-characters
            return row.city.normalize('NFD').replace(/\p{Diacritic}/gu, "") == arr[0] & row.iso2 == arr[1];
          });
          if (result.length > 0){
            console.log(result);
            yourcity = result[0];
            return yourcity
          }
        })
      }

  </script>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
    <div style="position: fixed; top:20; right:20; width:200px">
      <ul id="cities"></ul>
    </div>
    <div id="panel" style="position:fixed; top:20; left:20; color:silver;">
      <select id="epoch">
        <option value="equinox">equinox</option>
        <option value="now" selected>now</option>
      </select>
      <span id="current"></span>
      noon: <span id="noon"></span>
      frame: <span id="frame">0</span>
      your city:<input id="yourcity" type="text" value="Kobe,JP" oninput="updatecity()"><br/>

      <button id="resetT0" onclick="calcDate(this)">reset t0</button>
      season: <button id="seasonplus" onclick="calcDate(this)">+</button><button id="seasonminus" onclick="calcDate(this)">-</button>
      week: <button id="weekplus" onclick="calcDate(this)">+</button><button id="weekminus" onclick="calcDate(this)">-</button>
      day: <button id="dayplus" onclick="calcDate(this)">+</button><button id="dayminus" onclick="calcDate(this)">-</button>
      hour: <button id="hourplus" onclick="calcDate(this)">+</button><button id="hourminus" onclick="calcDate(this)">-</button>
      minute: <button id="minplus" onclick="calcDate(this)">+</button><button id="minminus" onclick="calcDate(this)">-</button>
      second: <button id="secplus" onclick="calcDate(this)">+</button><button id="secminus" onclick="calcDate(this)">-</button><br/>
      <label for="fov">fov: </label>
      <select id="fov">
        <option value="30">30</option>
        <option value="45" selected>45</option>
        <option value="60">60</option>
      </select>
      <label for="near">near: </label>
      <select id="near">
        <option value="1" selected>1</option>
        <option value="100">100</option>
        <option value="500">500</option>
      </select>
      <label for="far">far: </label>
      <select id="far">
        <option value="1500">1500</option>
        <option value="2000">2000</option>
        <option value="2500">2500</option>
        <option value="3000">3000</option>
        <option value="3500">3500</option>
        <option value="4000">4000</option>
        <option value="4500">4500</option>
        <option value="5000" selected>5000</option>
      </select>
      <label for="camera">camara distance</label>
      <select id="camera">
        <option value="1000" selected>1000</option>
        <option value="1500">1500</option>
        <option value="2000">2000</option>
        <option value="2500">2500</option>
        <option value="3000">3000</option>
        <option value="3500">3500</option>
        <option value="4000">4000</option>
      </select><br/>
      <span id="solarday"></span><br/>
      <span id="lunarday"></span><br/>
      <label for="perspective">perspective</label>
      <select id="perspective">
        <option value="0,1,0" selected>North</option>
        <option value="0,-1,0">South</option>
        <option value="1,0,0">Libra</option>
        <option value="-1,0,0">Aries</option>
        <option value="0,0,1">Scorpion</option>
        <option value="0,0,-1">Orion</option>
      </select><br/>
      <label for="radius">radius</label>
      <select id="radius">
        <option value="200">200</option>
        <option value="300" selected>300</option>
        <option value="400">400</option>
        <option value="500">500</option>
      </select>
      <label for="lineheight">lineheight</label>
      <select id="lineheight">
        <option value="1.05">1.05</option>
        <option value="1.1" selected>1.1</option>
        <option value="1.2">1.2</option>
        <option value="1.3">1.3</option>
        <option value="1.4">1.4</option>
        <option value="1.5">1.5</option>
        <option value="1.6">1.6</option>
      </select>
      <br/>
      sidereal year: <span id="loy">366.2422</span><br/>
      synodic month: <span id="lom">29.53059</span><br/>
      playspeed:
      <select id="playspeed">
        <option value="-600">-10 min/sec (-x600)</option>
        <option value="-60">-1 min/sec (-x60)</option>
        <option value="-30">-x30</option>
        <option value="-6">-x6</option>
        <option value="-2">-x2</option>
        <option value="-1">-x1</option>
        <option value="0">stop</option>
        <option value="1" selected>x1</option>
        <option value="2">x2</option>
        <option value="6">x6</option>
        <option value="30">x30</option>
        <option value="60">1 min/sec (x60)</option>
        <option value="600">10 min/sec (x600)</option>
        <option value="3600">1 hour/sec (x3600)</option>
        <option value="14400">6 hours/sec (x14400)</option>
        <option value="86400">1 day/sec (x86400)</option>
        <option value="590133">1 week /sec (x590133)</option>
        <option value="864000">10 days/sec (x864000)</option>
        <option value="2360534">1 month /sec (x2360534)</option>
        <option value="31643326">1 year /sec (x31643326)</option>
      </select>
      <span id="fpsd"></span><br/>
      sin(theta): <span id="sin">0</span><br/>
      cos(theta): <span id="cos">0</span><br/>
    </div>
  </body>
</html>
